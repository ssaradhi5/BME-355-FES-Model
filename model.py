import matplotlib.pyplot as plt
import numpy as np
from scipy.integrate import solve_ivp
import math
import csv
import interpolate_func
from sklearn.metrics import mean_squared_error


class FESModel:
    def __init__(self, excitation_input, external_state_vector):
        # Model constants for an average subject (75kg - 1.75m)
        self.TAct = 0.01  # Activation constant time [sec]
        self.TDeact = 0.04  # Relaxation constant time [sec]
        self.J = 0.0197  # Inertia of the foot around ankle [kg * m^2]
        self.d = 0.037  # Moment arm of TA w.r.t the ankle [m]
        self.B = 0.82  # Viscosity parameters
        self.cF = 0.1145  # COM location w.r.t the ankle [m]
        self.mF = 1.0275  # Mass of the foot [kg]
        self.aV = 1.33  # First force-velocity parameter
        self.fv1 = 0.18  # Second force-velocity parameter
        self.fv2 = 0.023  # Third force-velocity parameter
        self.vMax = -0.9  # Maximal contraction speed (shortnening) [m/sec]
        self.FMax = 600  # Maximal isometric force [N]
        self.W = 0.56  # Shape parameter of f-fl
        self.lT = 0.223  # Constant tendon length [m]
        self.lMT0 = 0.321  # Muscle-tendon length at rest [m]
        # Parameters of elastic torque T-Elastic
        self.a = [2.10, -0.08, -7.97, 0.19, -1.79]
        self.g = -9.81
        self.u = excitation_input
        self.x_ext = external_state_vector

    # EQN 4
    def roc_excitation(self, x, excitation_at_time):
        """
        :param x: state vector
        :param excitation_at_time: time value at excitation
        :return x1_dot: rate of change of dynamic level of muscle activation
        """
        # x1 dot = rate of chance of dynamic level of muscle activation
        # x1 = Factivation
        x1 = x[0]
        x1_dot = (excitation_at_time - x1) * ((excitation_at_time /
                                               self.TAct)+((1 - excitation_at_time) / self.TDeact))
        return x1_dot

    # EQN 5
    def rot_velocity(self, x):
        """
        :param x: state vector
        :return x2_dot: absolute rotational velocity
        """
        x3 = np.radians(x[2])
        x2_dot = x3
        return x2_dot

    # EQN 6
    def rot_acceleration(self, x, x_ext_at_time):
        """
        :param x: state vector
        :param x_ext_at_time: external value at x at a given time
        :return x3_dot: Rotational Acceleration
        """

        # Left is first term, right is last
        # TODO: Change paramaters to correct function names
        left = (1 / self.J) * (self.get_muscle_force(x, x_ext_at_time)) * self.d
        T_grav = self.tor_gravity(x)
        T_acc = self.tor_ankle(x, x_ext_at_time)
        T_ela = self.get_torque_elastic(x)
        right = self.B * (x_ext_at_time[3] - x[2])

        x3Dot = left + T_grav + T_acc + T_ela + right

        return x3Dot

    # EQN 7
    def tor_gravity(self, x):
        """
        :param x: state vector
        :return x3_dot: Torque of foot generated by gravity
        """

        # Output is a negative value
        x2 = x[1]

        return (-1 * self.mF * self.cF * math.cos(np.radians(x2) * self.g))

    # EQN 8
    def tor_ankle(self, x, x_ext_at_time):
        """
        :param x: state vector
        :param x_ext_at_time: external value at x at a given time
        :return: torque of foot generated by ankle movement
        """
        x1_ext = x_ext_at_time[0]
        x2_ext = x_ext_at_time[1]
        x2 = x[1]
        return (self.mF * self.cF * ((x1_ext * math.sin(np.radians(x2))) - (x2_ext * math.cos(np.radians(x2)))))

    # Equation 9 from Appendix A
    def get_torque_elastic(self, x):
        """
        :param x: state vector
        :return TEla: elastic torque of the ankle
        """
        a1 = self.a[0]
        a2 = self.a[1]
        a3 = self.a[2]
        a4 = self.a[3]
        a5 = self.a[4]
        x = np.radians(x)
        TEla = np.exp(a1 + a2 * x[1]) - np.exp(a3 + a4 * x[1]) + a5

        return TEla

    # Equation 10 from Appendix A
    def get_muscle_force(self, x, x_ext_at_time):
        """
        :param x: state vector
        :param x_ext: external state vector
        :return Fm: TA muscular force generated by simulation
        """
        Ffl = self.get_Ffl(x, x_ext_at_time)
        Ffv = self.get_Ffv(x, x_ext_at_time)

        Fm = x[0] * self.FMax * Ffl * Ffv * \
            (x_ext_at_time[2] - np.radians(x[2])) * \
            (x_ext_at_time[3] - np.radians(x[2]))

        return Fm

    # Equation 11 from Appendix A
    def get_Ffl(self, x, x_ext):
        """
        :param x: state vector
        :param x_ext: external state vector
        :return Ffl: relationship between force and ankle joint angle
        """

        # length of the muscle-tendon complex for the TA
        lMT = self.lMT0 + self.d * (x_ext[2] - x[1])
        lCE = lMT - self.lT  # length of contractile element muscle fibres
        # optimal length of CE fibre for maximal force ***CHECK***
        lCE_opt = self.lMT0 - self.lT

        Ffl = math.exp(-1 * math.pow(((lCE - lCE_opt)/(self.W*lCE_opt)), 2))

        return Ffl

    # Equation 12 from Appendix A
    def get_Ffv(self, x, x_ext):
        """
        :param x: state vector
        :param x_ext: external state vector
        :return Ffv: relationship between TA's CE muscle force and its contraction speed
        """
        Ffv = 0

        vCE = self.d * (x_ext[3] - np.radians(x[2]))

        # case 1: muscle is contracting
        if vCE < 0:
            Ffv = (1 - (vCE/self.vMax)) / (1 + (vCE / (self.vMax * self.fv1)))

        # case 2: muscle is extending or is isometric
        else:
            Ffv = (1 + (self.aV * (vCE / self.fv2))) / (1 + (vCE / self.fv2))

        return Ffv

    def get_derivative(self, t, x):
        """
        :param x: state variables [x1, x2, x3]
        :return: time derivatives of state variables [x1Dot, x2Dot, x3Dot]
        """

        x_ext_at_time = np.zeros(4)
        for i in range(len(self.x_ext)):
            x_ext_vector = self.x_ext[i]
            data_point_at_time = x_ext_vector[int(t)]
            x_ext_at_time[i] = data_point_at_time[1]

        excitation_at_time = self.u[int(t)]
        x1Dot = self.roc_excitation(x, excitation_at_time)
        x2Dot = self.rot_velocity(x)
        x3Dot = self.rot_acceleration(x, x_ext_at_time)

        xDotVector = [x1Dot, x2Dot, x3Dot]

        return xDotVector


def rootMeanSquaredError(output_array, test_array, label):
    """
    :param output_array: experimental data
    :param test_array: simulation outputs
    :return: MSE
    """
    val = math.sqrt((mean_squared_error(output_array, test_array)))
    print(label + " RMSE: " + str(val))
    return val


def simulate(excitation_input, external_state_vectors, initial_state, simTime):
    """
    :param excitation_input: activation function of TA excitation
    :param external_state_vectors: experiment data of external state vectors
    :param simTime: time of simulation
    :return: IVP arrays of time and values
    """
    simulationTime = [0, simTime]

    model = FESModel(excitation_input, external_state_vectors)

    sol = solve_ivp(model.get_derivative, simulationTime,
                    initial_state, rtol=1e-5, atol=1e-8, max_step=1)

    time = sol.t
    ret = sol.y

    return time, ret


def get_external_data(fileName):
    ret = []

    with open('InterpolatedData/' + fileName) as file:
        plots = csv.reader(file, delimiter=',')
        for row in plots:
            ret.append(np.array([float(row[0]), float(row[1])]))
    return ret


def plot_model(excitationInput, x_ext, label):
    initialState = np.array([0.0, -15.0, 0.0])

    time, testSim = simulate(excitationInput, x_ext, initialState, 359)

    dynamicActivationLevel = testSim[0, :]
    ankleAngle = testSim[1, :]
    footRotationalVelocity = testSim[2, :]

    fig, axis = plt.subplots(3)
    fig.suptitle(label)
    axis[0].plot(time, dynamicActivationLevel)
    axis[0].set_title("Dynamic Activation Level")

    axis[1].plot(time, ankleAngle)
    axis[1].set_title("Foot Angle wrt to Horiztonal")

    axis[2].plot(time, footRotationalVelocity)
    axis[2].set_title("Foot Rotational Velocity")
    fig.tight_layout()

    return testSim


def plot_foot_angles(excitationInputs, x_ext, labels):
    initialState = np.array([0.0, -15.0, 0.0])
    healthyTime = 0

    for i in range(len(excitationInputs)):
        time, testSim = simulate(excitationInputs[i], x_ext, initialState, 359)
        healthyTime = time

        ankleAngle = testSim[1, :]

        plt.plot(time, ankleAngle, label=labels[i])

    a_inter = interpolate_func.interpolateData(
        'ankleAngle2.csv', len(healthyTime))

    plt.plot(healthyTime, a_inter, label="Healthy Foot Angle")

    plt.xlabel('Time (ms)')
    plt.ylabel('Foot Angle (degrees)')
    plt.title('Foot Angle over time for various excitation inputs')
    plt.legend()
    plt.show()


def test_foot_angle(excitationInputs, x_ext, labels):
    initialState = np.array([0.0, -15.0, 0.0])
    healthyTime = 0

    for i in range(len(excitationInputs)):
        time, testSim = simulate(excitationInputs[i], x_ext, initialState, 359)
        healthyTime = time  # using same time as last foot angle output

        ankleAngle = testSim[1, :]
        plt.plot(time, ankleAngle, label=labels[i])

    a_inter = interpolate_func.interpolateData(
        'ankleAngle2.csv', len(healthyTime))

    plt.plot(healthyTime, a_inter, label="Healthy Foot Angle")

    plt.xlabel('Time (ms)')
    plt.ylabel('Foot Angle (degrees)')
    plt.title('Foot Angle over time for various constant excitation inputs')
    plt.legend()
    plt.show()


def run(find_u=False):
    # fileNames = ['x1_ext_data.csv_interpolated.csv', 'x2_ext_data.csv_interpolated.csv', 'x3_ext_data.csv_interpolated.csv', 'x4_ext_data.csv_interpolated.csv']

    #### Load Data ####
    extData1 = get_external_data('x1_ext_data.csv_interpolated.csv')
    extData2 = get_external_data('x2_ext_data.csv_interpolated.csv')
    extData3 = get_external_data('x3_ext_data.csv_interpolated.csv')
    extData4 = get_external_data('x4_ext_data.csv_interpolated.csv')

    # Converting angle degree into radians
    extData3 = np.radians(extData3)
    extData4 = np.radians(extData4)

    ### Generate excitation inputs ###
    excitation1 = np.genfromtxt(
        'excitation-data-paper.csv_interpolated.csv', delimiter=',')
    excitation2 = np.genfromtxt('trapezoid.csv', delimiter=',')
    excitation3 = np.full(360, 0.2)
    excitation4 = np.full(360, 1)
    excitation5 = np.genfromtxt('EMG_data_resampled.csv', delimiter=',')

    x_ext = np.array([extData1, extData2, extData3, extData4])

    initialState = np.array([0.0, -15, 0.0])

    # Find the best fitting constant value
    if find_u:
        u_values = np.arange(0, 1.1, 0.1)
        mse_scores = []
        for val in u_values:
            excitations = np.full(360, val)
            value = plot_model(excitations, x_ext, val)
            value_inter = interpolate_func.interpolateData(
                'ankleAngle2.csv', len(value[1]), 'ankleAngle1')
            test1_time, test1_ret = simulate(
                excitations, x_ext, initialState, 359)

            print("U value {}".format(val))
            mse_val = rootMeanSquaredError(test1_ret[1], value_inter)
            mse_scores.append(mse_val)

        mse = min(mse_scores)
        index = mse_scores.index(mse)
        best_u = u_values[index]
        print("BEST U {} " .format(best_u))

    ### Model set up and run ###
    excitationInputs = [excitation1, excitation2,
                        excitation3, excitation4, excitation5]
    labels = ["Literature Excitation Signal", "Trapezoid Excitation Signal",
              "Constant Excitation Signal (u = 0.2)", "Constant Excitation Signal (u = 1)", "EMG Envelope"]

    plot_foot_angles(excitationInputs, x_ext, labels)

    a = plot_model(excitation1, x_ext, "Literature Excitation Signal")
    a_inter = interpolate_func.interpolateData(
        'ankleAngle2.csv', len(a[1]))

    b = plot_model(excitation2, x_ext, "Trapezoid Excitation Signal")
    b_inter = interpolate_func.interpolateData(
        'ankleAngle2.csv', len(b[1]))

    c = plot_model(excitation3, x_ext, "Constant Excitation Signal (u = 0.2)")
    c_inter = interpolate_func.interpolateData(
        'ankleAngle2.csv', len(c[1]))

    d = plot_model(excitation4, x_ext, "Constant Excitation Signal (u = 1)")
    d_inter = interpolate_func.interpolateData(
        'ankleAngle2.csv', len(d[1]))

    e = plot_model(excitation5, x_ext, "EMG Envelope")
    e_inter = interpolate_func.interpolateData(
        'ankleAngle2.csv', len(e[1]))

    # -------------------------------------Model Testing------------------------------------------------------

    # 1. Sensitivity Analysis (u = 0 - 1 w/ increments = 0.1)
    # excitation1 = np.full(360, 0)
    # excitation2 = np.full(360, 0.1)
    # excitation3 = np.full(360, 0.2)
    # excitation4 = np.full(360, 0.3)
    # excitation5 = np.full(360, 0.4)
    # excitation6 = np.full(360, 0.5)
    # excitation7 = np.full(360, 0.6)
    # excitation8 = np.full(360, 0.7)
    # excitation9 = np.full(360, 0.8)
    # excitation10 = np.full(360, 0.9)
    # excitation11 = np.full(360, 1)
    # excitationInputsTest = [excitation1, excitation2,
    #                     excitation3, excitation4, excitation5, excitation6, excitation7, excitation8,
    #                     excitation9, excitation10, excitation11]
    # labelsTest = ["u = 0", "u = 0.1", "u = 0.2", "u = 0.3", "u = 0.4", "u = 0.5", "u = 0.6", "u = 0.7",
    #               "u = 0.8", "u = 0.9", "u = 1.0"]
    #
    # test_foot_angle(excitationInputsTest, x_ext, labelsTest)

    # --------------------------------------------------------------------------------------------------------

    # Show all generated figures
    plt.show()

  ## Root squared error between literature data and simulated data ###
    test1_time, test1_ret = simulate(excitation1, x_ext, initialState, 359)
    test2_time, test2_ret = simulate(excitation2, x_ext, initialState, 359)
    test3_time, test3_ret = simulate(excitation3, x_ext, initialState, 359)
    test4_time, test4_ret = simulate(excitation4, x_ext, initialState, 359)
    test5_time, test5_ret = simulate(excitation5, x_ext, initialState, 359)

    # print(test1_ret[1].shape)
    # print(a_inter.shape)

    rootMeanSquaredError(test1_ret[1], a_inter, labels[0])
    rootMeanSquaredError(test2_ret[1], b_inter, labels[1])
    rootMeanSquaredError(test3_ret[1], c_inter, labels[2])
    rootMeanSquaredError(test4_ret[1], d_inter, labels[3])
    rootMeanSquaredError(test5_ret[1], e_inter, labels[4])


if __name__ == "__main__":
    run()
