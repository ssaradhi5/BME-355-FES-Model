import matplotlib.pyplot as plt
import numpy as np
from scipy.integrate import solve_ivp
import math
import csv
import interpolate_func

from sklearn.metrics import mean_squared_error


class FESModel:
    def __init__(self, excitation_input, external_state_vector):
        # Model constants for an average subject (75kg - 1.75m)
        self.TAct = 0.01  # Activation constant time [sec]
        self.TDeact = 0.04  # Relaxation constant time [sec]
        self.J = 0.0197  # Inertia of the foot around ankle [kg * m^2]
        self.d = 0.037  # Moment arm of TA w.r.t the ankle [m]
        self.B = 0.82  # Viscosity parameters
        self.cF = 0.1145  # COM location w.r.t the ankle [m]
        self.mF = 1.0275  # Mass of the foot [kg]
        self.aV = 1.33  # First force-velocity parameter
        self.fv1 = 0.18  # Second force-velocity parameter
        self.fv2 = 0.023  # Third force-velocity parameter
        self.vMax = -0.9  # Maximal contraction speed (shortnening) [m/sec]
        self.FMax = 600  # Maximal isometric force [N]
        self.W = 0.56  # Shape parameter of f-fl
        self.lT = 0.223  # Constant tendon length [m]
        self.lMT0 = 0.321  # Muscle-tendon length at rest [m]
        # Parameters of elastic torque T-Elastic
        self.a = [2.10, -0.08, -7.97, 0.19, -1.79]
        self.g = -9.81
        self.u = excitation_input
        self.x_ext = external_state_vector

    # EQN 4
    def roc_excitation(self, x, excitation_at_time):
        # x1 dot = rate of chance of dynamic level of muscle activation
        # x1 = Factivation
        x1 = x[0]
        x1_dot = (excitation_at_time - x1) * ((excitation_at_time /
                                               self.TAct)+((1 - excitation_at_time) / self.TDeact))
        return x1_dot

    # EQN 5
    def rot_velocity(self, x):
        # x2_dot = absolute rotational velocity
        x3 = np.radians(x[2])
        x2_dot = x3
        return x2_dot

    # EQN 6
    def rot_acceleration(self, x, x_ext_at_time):
        # Rotational Acceleration. Left is first term, right is last
        # TODO: Change paramaters to correct function names
        left = (1 / self.J) * (self.get_muscle_force(x, x_ext_at_time)) * self.d
        T_grav = self.tor_gravity(x)
        T_acc = self.tor_ankle(x, x_ext_at_time)
        T_ela = self.get_torque_elastic(x)
        right = self.B * (x_ext_at_time[3] - x[2])

        x3Dot = left + T_grav + T_acc + T_ela + right

        return x3Dot

    # EQN 7
    def tor_gravity(self, x):
        # Torque of foot generated by gravity
        # Output is a negative value
        x2 = x[1]

        return (-1 * self.mF * self.cF * math.cos(np.radians(x2) * self.g))

    # EQN 8
    def tor_ankle(self, state_vector, x_ext_at_time):
        # Torque of foot generated by ankle movement
        x1_ext = x_ext_at_time[0]
        x2_ext = x_ext_at_time[1]
        x2 = state_vector[1]
        return (self.mF * self.cF * ((x1_ext * math.sin(np.radians(x2))) - (x2_ext * math.cos(np.radians(x2)))))

    # Equation 9 from Appendix A
    def get_torque_elastic(self, x):
        """
        :param x: state vector
        :return TEla: elastic torque of the ankle
        """
        a1 = self.a[0]
        a2 = self.a[1]
        a3 = self.a[2]
        a4 = self.a[3]
        a5 = self.a[4]
        x = np.radians(x)
        TEla = np.exp(a1 + a2 * x[1]) - np.exp(a3 + a4 * x[1]) + a5

        return TEla

    # Equation 10 from Appendix A
    def get_muscle_force(self, x, x_ext_at_time):
        """
        :param x: state vector
        :param x_ext: external state vector
        :return Fm: TA muscular force generated by simulation
        """
        Ffl = self.get_Ffl(x, x_ext_at_time)
        Ffv = self.get_Ffv(x, x_ext_at_time)

        Fm = x[0] * self.FMax * Ffl * Ffv * (x_ext_at_time[2] - np.radians(x[2])) * (x_ext_at_time[3] - np.radians(x[2]))

        return Fm

    # Equation 11 from Appendix A
    def get_Ffl(self, x, x_ext):
        """
        :param x: state vector
        :param x_ext: external state vector
        :return Ffl: relationship between force and ankle joint angle
        """

        # length of the muscle-tendon complex for the TA
        lMT = self.lMT0 + self.d * (x_ext[2] - x[1])
        lCE = lMT - self.lT  # length of contractile element muscle fibres
        # optimal length of CE fibre for maximal force ***CHECK***
        lCE_opt = self.lMT0 - self.lT

        Ffl = math.exp(-1 * math.pow(((lCE - lCE_opt)/(self.W*lCE_opt)), 2))

        return Ffl

    # Equation 12 from Appendix A
    def get_Ffv(self, x, x_ext):
        """
        :param x: state vector
        :param x_ext: external state vector
        :return Ffv: relationship between TA's CE muscle force and its contraction speed
        """
        Ffv = 0

        vCE = self.d * (x_ext[3] - np.radians(x[2]))

        # case 1: muscle is contracting
        if vCE < 0:
            Ffv = (1 - (vCE/self.vMax)) / (1 + (vCE / (self.vMax * self.fv1)))

        # case 2: muscle is extending or is isometric
        else:
            Ffv = (1 + (self.aV * (vCE / self.fv2))) / (1 + (vCE / self.fv2))

        return Ffv

    def get_derivative(self, t, x):
        """
        :param x: state variables [x1, x2, x3]
        :return: time derivatives of state variables [x1Dot, x2Dot, x3Dot]
        """
        # x_ext = [i[int(t * 1000)][1] for i in self.x_ext]
        # print(t)
        x_ext_at_time = np.zeros(4)
        for i in range(len(self.x_ext)):
            x_ext_vector = self.x_ext[i]
            data_point_at_time = x_ext_vector[int(t)]
            x_ext_at_time[i] = data_point_at_time[1]

        excitation_at_time = self.u[int(t)]
        x1Dot = self.roc_excitation(x, excitation_at_time)
        x2Dot = self.rot_velocity(x)
        x3Dot = self.rot_acceleration(x, x_ext_at_time)

        xDotVector = [x1Dot, x2Dot, x3Dot]

        return xDotVector


def meanSquaredError(output_array, test_array):
    output_array[int(len(output_array)/2)                 :] = output_array[int(len(output_array)/2):]
    val = (mean_squared_error(output_array, test_array))
    print(val)
    return val


def simulate(excitation_input, external_state_vectors, initial_state, simTime):
    simulationTime = [0, simTime]

    model = FESModel(excitation_input, external_state_vectors)

    sol = solve_ivp(model.get_derivative, simulationTime,
                    initial_state, rtol=1e-5, atol=1e-8, max_step=1)

    time = sol.t
    ret = sol.y

    return time, ret

def get_muscle_energy_consump(output_array, time_array):
    sum = 0

    # Taking midpoint Riemann sum
    for i in range(len(time_array)-1):
        sum = sum + ((time_array[i+1] - time_array[i]) * ((output_array[i+1] + output_array[i])/2))

    return sum

def get_external_data(fileName):
    ret = []

    with open('InterpolatedData/' + fileName) as file:
        plots = csv.reader(file, delimiter=',')
        for row in plots:
            ret.append(np.array([float(row[0]), float(row[1])]))
    return ret


if __name__ == "__main__":
    # fileNames = ['x1_ext_data.csv_interpolated.csv', 'x2_ext_data.csv_interpolated.csv', 'x3_ext_data.csv_interpolated.csv', 'x4_ext_data.csv_interpolated.csv']

    extData1 = get_external_data('x1_ext_data.csv_interpolated.csv')
    extData2 = get_external_data('x2_ext_data.csv_interpolated.csv')
    extData3 = get_external_data('x3_ext_data.csv_interpolated.csv')
    extData4 = get_external_data('x4_ext_data.csv_interpolated.csv')

    extData3 = np.radians(extData3)
    extData4 = np.radians(extData4)
    # print(extData1)

    # time = np.linspace(0, 0.36, 360)
    #
    # fig, axis = plt.subplots(4)
    # axis[0].plot(time, extData1)
    # axis[0].set_title("Horizontal Ankle Acceleration")
    #
    # axis[1].plot(time, extData2)
    # axis[1].set_title("Vertical Ankle Acceleration")
    #
    # axis[2].plot(time, extData3)
    # axis[2].set_title("Shank Angle")
    #
    # axis[3].plot(time, extData4)
    # axis[3].set_title("Rotational Velocity of Shank")
    #
    # fig.tight_layout()
    # plt.show()

    def plot_model(excitationInput, x_ext, label):
        initialState = np.array([0.0, -15.0, 0.0])

        time, testSim = simulate(excitationInput, x_ext, initialState, 359)

        dynamicActivationLevel = testSim[0, :]
        ankleAngle = testSim[1, :]
        #ankleAngle[150:] = ankleAngle[150:]-25
        footRotationalVelocity = testSim[2, :]

        fig, axis = plt.subplots(3)
        fig.suptitle(label)
        axis[0].plot(time, dynamicActivationLevel)
        axis[0].set_title("Dynamic Activation Level")

        axis[1].plot(time, ankleAngle)
        axis[1].set_title("Ankle Angle")

        axis[2].plot(time, footRotationalVelocity)
        axis[2].set_title("Foot Rotational Velocity")
        fig.tight_layout()

        return testSim

    def plot_foot_angles(excitationInputs, x_ext, labels):
        initialState = np.array([0.0, -15.0, 0.0])

        time1, testSim1 = simulate(excitationInputs[0], x_ext, initialState, 359)
        time2, testSim2 = simulate(excitationInputs[1], x_ext, initialState, 359)
        time3, testSim3 = simulate(excitationInputs[2], x_ext, initialState, 359)
        time4, testSim4 = simulate(excitationInputs[3], x_ext, initialState, 359)
        time5, testSim5 = simulate(excitationInputs[4], x_ext, initialState, 359)
        ankleAngle1 = testSim1[1, :]
        ankleAngle2 = testSim2[1, :]
        ankleAngle3 = testSim3[1, :]
        ankleAngle4 = testSim4[1, :]
        ankleAngle5 = testSim5[1, :]

        plt.plot(time1, ankleAngle1, label = labels[0])
        plt.plot(time2, ankleAngle2, label = labels[1])
        plt.plot(time3, ankleAngle3, label = labels[2])
        plt.plot(time4, ankleAngle4, label = labels[3])
        plt.plot(time5, ankleAngle5, label = labels[4])
        plt.xlabel('Time (ms)')
        plt.ylabel('Foot Angle (degrees)')
        plt.title('Foot Angle over time for various excitation inputs')
        plt.legend()
        plt.show()

    excitation1 = np.genfromtxt(
        'excitation-data-paper.csv_interpolated.csv', delimiter=',')
    excitation2 = np.genfromtxt('trapezoid.csv', delimiter=',')
    excitation3 = np.full(360, 0.2)
    excitation4 = np.full(360, 1)
    excitation5 = np.genfromtxt('EMG_data_resampled.csv', delimiter=',')
    # print(excitation)

    x_ext = np.array([extData1, extData2, extData3, extData4])

    initialState = np.array([0.0, -15, 0.0])

    # u_values = np.arange(0, 1.1, 0.1)
    # mse_scores = []
    # for val in u_values:
    #     excitations = np.full(360, val)
    #     value = plot_model(excitations, x_ext, val)
    #     value_inter = interpolate_func.interpolateData(
    #         'ankleAngle2.csv', len(value[1]), 'ankleAngle1')
    #     test1_time, test1_ret = simulate(excitations, x_ext, initialState, 359)

    #     print("U value {}".format(val))
    #     mse_val = meanSquaredError(test1_ret[1], value_inter)
    #     mse_scores.append(mse_val)

    # print(mse_scores)
    # mse = min(mse_scores)
    # print("MSE")
    # print(mse)
    # index = mse_scores.index(mse)
    # print("MSE index")
    # print(index)
    # best_u = u_values[index]
    # print("BEST U {} " .format(best_u))

    excitationInputs = [excitation1, excitation2, excitation3, excitation4, excitation5]
    labels = ["Literature Excitation Signal", "Trapezoid Excitation Signal", "Constant Excitation Signal (u = 0.2)", "Constant Excitation Signal (u = 1)", "EMG Envelope"]
    plot_foot_angles(excitationInputs, x_ext, labels)
    a = plot_model(excitation1, x_ext, "Literature Excitation Signal")
    a_inter = interpolate_func.interpolateData(
        'ankleAngle2.csv', len(a[1]), 'ankleAngle1')

    b = plot_model(excitation2, x_ext, "Trapezoid Excitation Signal")
    b_inter = interpolate_func.interpolateData(
        'ankleAngle2.csv', len(b[1]), 'ankleAngle2')

    c = plot_model(excitation3, x_ext, "Constant Excitation Signal (u = 0.2)")
    c_inter = interpolate_func.interpolateData(
        'ankleAngle2.csv', len(c[1]), 'ankleAngle3')

    d = plot_model(excitation4, x_ext, "Constant Excitation Signal (u = 1)")
    d_inter = interpolate_func.interpolateData(
        'ankleAngle2.csv', len(d[1]), 'ankleAngle4')

    e = plot_model(excitation5, x_ext, "EMG Envelope")
    e_inter = interpolate_func.interpolateData(
        'ankleAngle2.csv', len(e[1]), 'ankleAngle5')

    plt.show()


# def mse():
  # mean squared error between literature data and simulated data
    test1_time, test1_ret = simulate(excitation1, x_ext, initialState, 359)
    test2_time, test2_ret = simulate(excitation2, x_ext, initialState, 359)
    test3_time, test3_ret = simulate(excitation3, x_ext, initialState, 359)
    test4_time, test4_ret = simulate(excitation4, x_ext, initialState, 359)
    test5_time, test5_ret = simulate(excitation5, x_ext, initialState, 359)

    # print(test1_ret[1].shape)
    # print(a_inter.shape)


    # fig1, axis1 = plt.subplots(2)
    # axis1[0].plot(test1_ret[1])
    # axis1[1].plot(a_inter)
    # axis1[0].set_title('Literature Excitation')
    # plt.show()
    #
    # fig2, axis2 = plt.subplots(2)
    # axis2[0].plot(test2_ret[1])
    # axis2[1].plot(b_inter)
    # axis2[0].set_title('Trapezoid Excitation')
    # plt.show()
    #
    # fig3, axis3 = plt.subplots(2)
    # axis3[0].plot(test3_ret[1])
    # axis3[1].plot(c_inter)
    # axis3[0].set_title('Const Excitation (u=0.2)')
    # plt.show()
    #
    # fig4, axis4 = plt.subplots(2)
    # test4_ret[150:] = test4_ret[150:] - 25
    # axis4[0].plot(test4_ret[1])
    # axis4[1].plot(d_inter)
    # axis4[0].set_title('Const Excitation (u=1)')
    # plt.show()
    #
    # fig5, axis5 = plt.subplots(2)
    # axis5[0].plot(test5_ret[1])
    # axis5[1].plot(e_inter)
    # axis5[0].set_title('EMG Envelope')
    # plt.show()

    meanSquaredError(test1_ret[1], a_inter)
    meanSquaredError(test2_ret[1], b_inter)
    meanSquaredError(test3_ret[1], c_inter)
    meanSquaredError(test4_ret[1], d_inter)
    meanSquaredError(test5_ret[1], e_inter)


    # Get energy consumption dynamic activation level (testx_ret[0])
    # energyConsump1 = get_muscle_energy_consump(test1_ret[0], test1_time)
    # print('Literature excitation energy consumption: ' +str(energyConsump1))
    #
    # energyConsump2 = get_muscle_energy_consump(test2_ret[0], test2_time)
    # print('Trapezoid excitation energy consumption: ' +str(energyConsump2))
    #
    # energyConsump3 = get_muscle_energy_consump(test3_ret[0], test3_time)
    # print('Constant (0.2) excitation energy consumption: ' +str(energyConsump3))
    #
    # energyConsump4 = get_muscle_energy_consump(test4_ret[0], test4_time)
    # print('Constant (1) excitation energy consumption: ' +str(energyConsump4))
    #
    # energyConsump5 = get_muscle_energy_consump(test5_ret[0], test5_time)
    # print('EMG excitation energy consumption: ' +str(energyConsump5))





