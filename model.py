import matplotlib as plt
import numpy as np
<<<<<<< HEAD
import math



class FESModel:
  def __init__(self):
    # Model constants for an average subject (75kg - 1.75m)
    self.Tact = 0.01 # Activation constant time [sec]
    self.Tdeact = 0.04 # Relaxation constant time [sec]
=======
from scipy.integrate import solve_ivp
import math

class FESModel:
  def __init__(self, excitation_input):
    # Model constants for an average subject (75kg - 1.75m)
    self.TAct = 0.01 # Activation constant time [sec]
    self.TDeact = 0.04 # Relaxation constant time [sec]
>>>>>>> main
    self.J = 0.0197 # Inertia of the foot around ankle [kg * m^2]
    self.d = 3.7 # Moment arm of TA w.r.t the ankle [cm]
    self.B = 0.82 # Viscosity parameters
    self.cF = 11.45 # COM location w.r.t the ankle [cm]
    self.mF = 1.0275 # Mass of the foot [kg]
    self.aV = 1.33 # First force-velocity parameter
    self.fv1 = 0.18 # Second force-velocity parameter
<<<<<<< HEAD
    self.fv2 = 0.023 # Third force-veloctiy parameter
=======
    self.fv2 = 0.023 # Third force-velocity parameter
>>>>>>> main
    self.vMax = -0.9 # Maximal contraction speed (shortnening) [m/sec]
    self.FMax = 600 # Maximal isometric force [N]
    self.W = 0.56 # Shape parameter of f-fl
    self.lT = 22.3 # Constant tendon length [cm]
    self.lMT0 = 32.1 # Muscle-tendon length at rest [cm]
    self.a = [2.10, -0.08, -7.97, 0.19, -1.79] # Parameters of elastic torque T-Elastic
<<<<<<< HEAD
    self.g=9.81


#EQN 4
  def roc_excitation(self,sv,T_act,T_deact):
#x1 dot = rate of chance of dynamic level of muscle activation
#x1 = Factivation
    x1=sv[0]
    x1_dot=(u-x1)*((u/T_act)-((1-u)/T_deact))
    return x1_dot
  
#EQN 5
  def rot_velocity(self,sv):
  #x2_dot = absolute rotational velocity
    x2_dot=sv[2]
    return x2_dot

#EQN 6
  def rot_acceleration(self,sv,u,external_sv):
# Rotational Acceleration. Left is first term, right is last
#TODO: Change paramaters to correct function names
    left=(1/self.J)*(self.get_muscle_force(sv,u))*self.d
    T_grav=self.tor_gravity(sv[1])
    T_acc=self.tor_ankle(external_sv,sv)
    T_ela=self.get_torque_elastic(sv)
    right=self.B*(external_sv[3]-sv[2])

    return(left+T_grav+T_acc+T_ela+right)

#EQN 7
  def tor_gravity(self,sv):
#Torque of foot generated by gravity
#Output is a negative value
    x2 = sv[1]
    return (-self.mF*self.cF*math.cos(x2)*self.g)

# EQN 8
  def tor_ankle(self,sv,external_sv):
#Torque of foot generated by ankle movement
    x1_ext=external_sv[0]
    x2_ext=external_sv[1]
    x2=sv[1]
    return(self.mF*self.cF*((x1_ext*math.sin(x2))-(x2_ext*math.cos(x2))))
=======
    self.g = 9.81
    self.u = excitation_input

  # EQN 4
  def roc_excitation(self, sv, T_act, T_deact):
    # x1 dot = rate of chance of dynamic level of muscle activation
    # x1 = Factivation
    x1 = sv[0]
    x1_dot = (self.u - x1) * ((self.u / T_act) - ((1 - self.u) / T_deact))
    return x1_dot

  # EQN 5
  def rot_velocity(self, sv):
    # x2_dot = absolute rotational velocity
    x2_dot = sv[2]
    return x2_dot

  # EQN 6
  def rot_acceleration(self, sv, u, external_sv):
    # Rotational Acceleration. Left is first term, right is last
    # TODO: Change paramaters to correct function names
    left = (1 / self.J) * (self.get_muscle_force(sv, u)) * self.d
    T_grav = self.tor_gravity(sv[1])
    T_acc = self.tor_ankle(external_sv, sv)
    T_ela = self.get_torque_elastic(sv)
    right = self.B * (external_sv[3] - sv[2])

    return (left + T_grav + T_acc + T_ela + right)

  # EQN 7
  def tor_gravity(self, sv):
    # Torque of foot generated by gravity
    # Output is a negative value
    x2 = sv[1]
    return (-self.mF * self.cF * math.cos(x2) * self.g)

  # EQN 8
  def tor_ankle(self, sv, external_sv):
    # Torque of foot generated by ankle movement
    x1_ext = external_sv[0]
    x2_ext = external_sv[1]
    x2 = sv[1]
    return (self.mF * self.cF * ((x1_ext * math.sin(x2)) - (x2_ext * math.cos(x2))))

  # Equation 9 from Appendix A
  def get_torque_elastic (self, x):
    """
    :param x: state vector
    :return TEla: elastic torque of the ankle
    """
    a1 = self.a[0]
    a2 = self.a[1]
    a3 = self.a[2]
    a4 = self.a[3]
    a5 = self.a[4]

    TEla = math.exp(a1 + a2 * x[1]) - math.exp(a3 + a4 * x[1]) + a5

    return TEla

  # Equation 10 from Appendix A
  def get_muscle_force(self, x, x_ext):
    """
    :param x: state vector
    :param x_ext: external state vector
    :return Fm: TA muscular force generated by simulation
    """
    Ffl = self.get_Ffl(x, x_ext)
    Ffv = self.get_Ffv(x, x_ext)
    Fm = x[0] * self.FMax * Ffl * Ffv

    return Fm

  # Equation 11 from Appendix A
  def get_Ffl(self, x, x_ext):
    """
    :param x: state vector
    :param x_ext: external state vector
    :return Ffl: relationship between force and ankle joint angle
    """

    lMT = self.lMT0 + self.d * (x_ext[2] - x[1])  # length of the muscle-tendon complex for the TA
    lCE = lMT - self.lT # length of contractile element muscle fibres
    lCE_opt = self.lMT0 - self.lT # optimal length of CE fibre for maximal force ***CHECK***

    Ffl = math.exp(- math.pow( (lCE - lCE_opt)/(self.W*lCE_opt), 2))

    return Ffl

  # Equation 12 from Appendix A
  def get_Ffv(self, x, x_ext):
    """
    :param x: state vector
    :param x_ext: external state vector
    :return Ffv: relationship between TA's CE muscle force and its contraction speed
    """
    Ffv = 0

    vCE = self.d * (x_ext[3] - x[2])

    # case 1: muscle is contracting
    if vCE < 0:
      Ffv = ( 1 - (vCE/self.vMax) ) / ( 1 + (vCE / (self.vMax * self.fv1) ) )

    # case 2: muscle is extending or is isometric
    else:
      Ffv = ( 1 - self.aV * (vCE / self.fv2) ) / ( 1 + (vCE / self.fv2) )

    return Ffv




>>>>>>> main


